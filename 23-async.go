package main

import (
	"fmt"
	"time"
)

func say(greet string, ch chan string, ch2 chan int) {
	fmt.Println(greet)
	// ось так записуються дані в канал
	ch <- "Hello from ch"
	ch2 <- 8
}

func asynch() {
	// в go є канали між потоками, їх може бути скільки завгодно, створюємо його
	ch := make(chan string)
	ch2 := make(chan int)

	// декілька процесів можуть відбуватись паралельно через асинхронність
	// асинхронною можна зробити функцію за допомогою go, вона буде відбуватись в окремому потоці
    go say("Hello", ch, ch2)

	// заморожуємо основний поток за допомогою time на 2 секунди, щоб асинхронна функція встигла виконатись
	time.Sleep(2 * time.Second)

    // витягуємо дані з каналу
	fmt.Println(<-ch, <-ch2)
	// виведе спочатку Hello, а потім через дві секунди "Hello from ch"
	// якщо використовуємо канал, то нам вже не потрібно time.Sleep(2 * time.Second), бо основний поток дочекається отримання даних з каналу і все прийде одночасно
}






// канали можна закривати, наприклад якщо є цикл і головний поток чекає виконання циклу і не знає, коли цикл завершиться, щоб не було помилки
func say2(greet string, ch chan int) {
	for i := 0; i <= 5; i++ {
		ch <- i
	}

	close(ch)
	// канал закритий і працювати з ним вже не можна буде
}

func asynch2() {
	ch := make(chan int)
    go say2("Hello", ch)

    for a := range ch {
		fmt.Println(a)
	}
}